
plugins {
    id 'java'
    //----------------------------------------------------------------------------------------------------------
    // This part still isn't clear to me. I need these two plugins only for the Spring Boot subproject.
    // If I try to declare them only in the subproject 'build.gradle.kts' file, then I end up with errors
    // in the build scripts inside IntelliJ.
    // With these two declarations also added here, things work again. I'm guessing the 'apply false' is
    // where the magic happens. The plugin requirements are declared here, but only 'applied' in my subproject?
    id 'org.springframework.boot' version '2.2.5.RELEASE' apply false
    // REFERENCE: https://mvnrepository.com/artifact/io.spring.dependency-management/io.spring.dependency-management.gradle.plugin
    id 'io.spring.dependency-management' version '1.0.9.RELEASE' apply false
    //----------------------------------------------------------------------------------------------------------
}

// Add IntelliJ IDEA plugin
apply plugin: 'idea'

def baseGroupForSubprojects = 'com.jimtough.gradle.mp'

// The settings inside this Closure will be applied to the root project and each subproject.
// The delegate object type is 'Project'.
allprojects {
    apply plugin: 'java'

    version = '0.1.0-SNAPSHOT'

    // Pull all dependencies from Maven Central and JCenter
    repositories {
        mavenCentral()
        jcenter()
    }
}

// The settings inside this Closure will be applied to each subproject, but NOT the root project.
// The delegate object type is 'Project'.
subprojects {
    sourceCompatibility = 1.8
    targetCompatibility = 1.8

    // TODO remove this later...
    group = 'com.jimtough'

    dependencies {
        implementation('org.slf4j:slf4j-api') {
            version {
                // Allow any 1.7.x release
                strictly '[1.7, 1.8['
                // Default to 1.7.22 if nothing else depends on this artifact and requests a different version
                prefer '1.7.25'
            }
        }

        // Use JUnit Jupiter API for testing
        testImplementation('org.junit.jupiter:junit-jupiter-api:5.4.2')
        // Use JUnit Jupiter Engine for testing
        testRuntimeOnly('org.junit.jupiter:junit-jupiter-engine:5.4.2')
        // Use Logback when running unit tests
        testRuntimeOnly('ch.qos.logback:logback-classic') {
            version {
                // Always use a 1.2.x release of Logback
                strictly '[1.2, 1.3['
            }
        }
    }

    tasks {
        jar {
            manifest {
                mf -> mf.attributes 'hi' : 'mom',
                        'Implementation-Title' : project.name,
                        'Implementation-Version' : project.version
            }
        }
        test {
            // Use JUnit 5
            useJUnitPlatform()
        }
    }

}

//-------------------------------------------------------------------------------------------------
// In this section, project-specific configuration is applied to subprojects by name.
// NOTE: Must use colon-prefix notation when referring to a subproject by name.
//       In the case where subprojects are nested more than one level deep (not done in this example),
//       one must separate each nesting level with a colon like ':childprj:grandchildprj'.
// NOTE: Another alternative is to put subproject-specific configuration into the 'build.gradle'
//       file for each subproject. I don't know if there are limitations to either approach,
//       or if this is simply a matter of developer preference.
project(':library-hello-factory') {
    group = '${baseGroupForSubprojects}.hellofactory'

    // This plugin is needed for library projects that produce a single JAR as output
    apply plugin: 'java-library'

    dependencies {
        // This library uses Google Guava internally, but is it not exposed in any public API.
        // Example of 'implementation' dependency scope.
        implementation 'com.google.guava:guava:27.1-jre'
    }
}
project(':library-world-factory') {
    group = '${baseGroupForSubprojects}.worldfactory'

    // This plugin is needed for library projects that produce a single JAR as output
    apply plugin: 'java-library'
}
project(":app-console-helloworld") {
    group = '${baseGroupForSubprojects}.helloworld'

    dependencies {
        // Declare dependencies on sibling library projects
        implementation(project(':library-hello-factory'))
        implementation(project(':library-world-factory'))
        // Use Logback as the slf4j implementation for this app when packaged/deployed
        implementation('ch.qos.logback:logback-classic') {
            version {
                // Use a 1.2.x version
                strictly '[1.2, 1.3['
            }
        }
    }

    tasks {
        jar {
            // The console app must have a manifest file that specifies the entry point class name.
            // NOTE: The attributes appear to be additive with respect to the 'subprojects' block.
            //       The attributes defined in the manifest config for 'jar' in subprojects are also used here.
            manifest {
                mf -> mf.attributes 'Main-Class' : 'com.jimtough.gradle.mp.helloworld.console.HelloWorldApp'
            }
            // Because of the 'from' below, which builds an uberjar, we depend on the sibling library
            // projects being built and packaged in their own JARs first.
            dependsOn ':library-hello-factory:jar'
            dependsOn ':library-world-factory:jar'
            // The 'from' below will package all 'runtimeClasspath' files/classes into the output JAR.
            // This will result in the console app being packed as a runnable uberjar/fatjar.
            from {
                // Now we need to unpack the individual files from each runtime classpath JAR file,
                // so they can be repacked into the uberjar we are building for this application
                // VERBOSE SYNTAX:
                //project.configurations.runtimeClasspath.collect { File file -> project.zipTree(file) }
                // CONCISE SYNTAX:
                project.configurations.runtimeClasspath.collect { project.zipTree(it) }
            }
        }
    }
}
//--------------------------------------------------------------------------------------

// Applies to entire build
tasks {
    wrapper {
        gradleVersion = '6.2.2'
        distributionType = Wrapper.DistributionType.ALL
    }
}
